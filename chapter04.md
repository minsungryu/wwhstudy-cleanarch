# 04 유스케이스 구현하기

한 계좌에서 다른 계좌로 송금하는 경우

## 도메인 모델 구현하기

> 코드는 다음 [링크](https://github.com/wikibook/clean-architecture/blob/main/src/main/java/io/reflectoring/buckpal/account/domain/Account.java)를 참고한다.

`Account` 엔티티는 실제 계좌의 현재 스냅샷이다.
계좌에 대한 모든 입금과 출금이 `Activity` 엔티티에 포착된다.
그러나 한 계좌에 대한 모든 활동을 한 번에 메모리에 올릴 수 없기 때문에
`ActivityWindow` 값 객체를 통해 지난 며칠 혹은 몇 주간의 범위에 해당하는 활동만 보유한다.

계좌의 현재 잔고를 계산하기 위해 `Account` 엔티티는 `baselineBalance` 속성을 가지고 있다.
현재 총 잔고는 기준 잔고(baselineBalance)에 활동창의 모든 활동들의 잔고를 합한 값이 된다.

## 유스케이스 둘러보기

일반적으로 유스케이스는 다음 단계를 따른다.

> 1. 입력을 받는다 
> 2. 비즈니스 규칙을 검증한다 
> 3. 모델 상태를 조작한다 
> 4. 출력을 반환한다

유스케이스는 인커밍 어댑터로부터 입력을 받는다.
저자는 유스케이스 코드가 도메인 로직에만 신경 써야 하고입력 유효성 검증으로 오염되면 안 된다고 생각한다.
이를 어디서 처리할지는 뒤에서 소개한다.

유스케이스는 **비즈니스 규칙을 검증할 책임**이 있다. 그리고 도메인 엔티티와 이 책임을 공유한다.
후반부에서 입력 유효성 검증과 비즈니스 규칙 검증의 차이점에 대해 다룬다.

> 코드는 다음 [링크](https://github.com/wikibook/clean-architecture/blob/main/src/main/java/io/reflectoring/buckpal/account/application/service/SendMoneyService.java)를 참고한다.

서비스는 인커밍 포트 인터페이스인 `SendMoneyUseCase`를 구현하고, 계좌를 불러오기 위해 아웃고잉 포트 인터페이스인 `LoadAccountPort`를 호출한다.
그리고 데이터베이스의 계좌 상태를 업데이트하기 위해 `UpdateAccountStatePort`를 호출한다.

## 입력 유효성 검증

호출하는 어댑터가 유스케이스에 입력을 전달하기 전에 입력 유효성을 검증하는 것은 신뢰하기 어렵다.
유스케이스가 하나 이상의 어댑터에서 호출될 경우 더욱 그러하다.

입력 모델의 생성자에서 입력 유효성을 검증하면 된다.

> 코드는 다음 [링크](https://github.com/wikibook/clean-architecture/blob/main/src/main/java/io/reflectoring/buckpal/account/application/port/in/SendMoneyCommand.java)를 참고한다.

필드를 불변으로 선언하고 객체를 생성할 때 예외를 던지면 유효한 상태의 객체가 변경되지 않는다는 것을 보장할 수 있다.
이는 유스케이스 API의 일부이므로 인커밍 포트 패키지에 위치한다. 그러므로 유스케이스 코드를 오염시키지도 않는다.

Bean Validation API를 사용하여 필드를 검증할 수도 있다.

이런 입력 모델 유효성 검증은 사실상 유스케이스 주위에 오류 방지 계층(anti corruption layer)을 만들어준다.
이는 잘못된 입력을 호출자에게 돌려주는 보호막 역할을 한다.

## 생성자의 힘

필드가 많아질 경우 빌더를 추가할 수 있지만 컴파일 시 오류를 잡아주지 못한다.
IDE의 도움을 받을 수 있는 경우 생성자를 써도 좋을 것 같다.

## 유스케이스마다 다른 입력 모델

각기 다른 유스케이스에 동일한 입력 모델을 사용하고 싶을 수 있다.
그러나 한 유스케이스에서 특정 필드가 필요하지 않을 경우 `null` 값을 허용해야 하는데 그 자체로 코드 스멜이다.
그보다 더 문제는 서로 다른 유스케이스에 대해 어떻게 입력 유효성을 검증하느냐다.

각 유스케이스 전용 입력 모델을 사용하라.
이는 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과를 발생하지 않게 한다.

## 비즈니스 규칙 검증하기

입력 유효성 검증이 아닌 비즈니스 규칙 검증은 유스케이스 로직의 일부분이다.
비즈니스 규칙에 대한 검증은 도메인 모델의 현재 상태에 접근해야함을 의미한다.
반면 입력 유효성 검증은 그럴 필요가 없다.

- 입력 유효성: 구문상의 유효성 검증
  - 예) "출금 계좌는 초과 출금되어서는 안 된다" -> 모델의 현재 상태에 접근해야하므로 비즈니스 규칙
- 비즈니스 규칙: 유스케이스의 맥락 속 의미적인 유효성 검증
  - 예) "송금되는 금액은 0보다 커야 한다" -> 모델에 접근하지 않고도 검증될 수 있는 입력 유효성 검증

비즈니스 규칙은 도메인 엔티티 안에 넣는 것이 좋다.
만약 여의치 않은 경우 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 해도 된다.

> `canExecute/Execute` 패턴이 도움이 될 것 같다.

## 풍부한 도메인 모델 vs. 빈약한 도메인 모델

이 책의 아키텍처 스타일은 도메인 모델을 구현하는 방법에 대해서는 열려 있다.

부디 DDD를 은탄환으로 여기는 사람이 없길 바란다.
빈약한 도메인 모델은 다른 말로는 함수형 프로그래밍이 가능한 모델이다.

## 유스케이스마다 다른 출력 모델

'송금하기' 유스케이스에서 `boolean`값 하나를 반환했다. 그러나 `Account`를 통째로 반환하고 싶을 수도 있다.
정답은 없지만 유스케이스를 가능한 구체적으로 유지하도록 계속 질문해야 한다. 의심스럽다면 가능한 한 적게 반환하자.

유스케이스 간의 출력 모델을 공유하지 않는 것 역시 단일 책임 원칙을 적용하고 유스케이스간 결합을 제거하는데 도움이 된다.
같은 이유로 도메인 모델을 출력 모델로 사용하지 말아야 한다.

## 읽기 전용 유스케이스는 어떨까?

읽기 전용 작업을 유스케이스라고 언급하는 것은 조금 이상하다.
만약 전체 프로젝트 맥락에서 이러한 작업이 유스케이스로 분류된다면 어떻게든 다른 유스케이스와 비슷한 방식으로 구현해야 한다.

하지만 애플리케이션 코어 관점에서 이 작업은 간단한 데이터 쿼리다.
그렇기 때문에 유스케이스로 간주되지 않는다면 실제 유스케이스와 구분하기 위해 쿼리로 구현할 수 있다.

읽기 전용 쿼리는 쓰기가 가능한 유스케이스와 구분된다.
이런 방식은 CQS(Command-Query Separation)나 CQRS(Command-Query Responsibility Segregation) 개념과 잘 맞는다.

---

질문 1. 어떤 사람들은 명령 객체의 생성자 유효성 검사에 대해 회의적이다. 어떻게 생각하는가?

질문 2. 유스케이스와 쿼리의 구분을 어떻게 할 수 있을까? 단순히 읽기 전용이라고 쿼리 모델로 분류하기 애매한 것 같다.